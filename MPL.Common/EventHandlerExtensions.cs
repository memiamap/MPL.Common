using System;
using System.Runtime.Remoting.Messaging;
using System.Threading.Tasks;

namespace MPL.Common
{
    /// <summary>
    /// A class that defines extensions methods for an Event Handler.
    /// </summary>
    public static class EventHandlerExtensions
    {
        #region Methods
        #region _Private_
        private static void EndEventProcess(IAsyncResult asyncResult)
        {
            try
            {
                AsyncResult result;

                result = (AsyncResult)asyncResult;
                if (result.AsyncDelegate is EventHandler eventHandler)
                    eventHandler.EndInvoke(asyncResult);
            }
            catch
            { }
        }
        private static void EndEventProcess<TEventArgs>(IAsyncResult asyncResult)
            where TEventArgs : EventArgs
        {
            try
            {
                AsyncResult result;

                result = (AsyncResult)asyncResult;
                if (result.AsyncDelegate is EventHandler<TEventArgs> eventHandler)
                    eventHandler.EndInvoke(asyncResult);
            }
            catch
            { }
        }

        private static void InvokeListeners(object sender, EventHandler[] eventHandlers)
        {
            foreach (EventHandler eventHandler in eventHandlers)
            {
                eventHandler.BeginInvoke(sender, new EventArgs(), EndEventProcess, null);
            }
        }
        private static void InvokeListeners<TEventArgs>(object sender, EventHandler<TEventArgs>[] eventHandlers, Func<TEventArgs> eventArgsFactory)
            where TEventArgs : EventArgs
        {
            foreach (EventHandler<TEventArgs> eventHandler in eventHandlers)
            {
                TEventArgs eventArgs;

                eventArgs = eventArgsFactory.Invoke();
                eventHandler.BeginInvoke(sender, eventArgs, EndEventProcess<TEventArgs>, null);
            }
        }

        private static bool TryGetEventHandlers(EventHandler eventHandler, out EventHandler[] eventHandlers)
        {
            Delegate[] eventSubscribers;
            bool returnValue = true;

            eventSubscribers = eventHandler.GetInvocationList();
            eventHandlers = new EventHandler[eventSubscribers.Length];

            for (int i = 0; i < eventSubscribers.Length; i++)
            {
                if (eventSubscribers[i] is EventHandler eventHandlerItem)
                    eventHandlers[i] = eventHandlerItem;
                else
                {
                    returnValue = false;
                    break;
                }
            }

            if (!returnValue)
                eventHandlers = null;

            return returnValue;
        }
        private static bool TryGetEventHandlers<TEventArgs>(EventHandler<TEventArgs> eventHandler, out EventHandler<TEventArgs>[] eventHandlers)
            where TEventArgs : EventArgs
        {
            Delegate[] eventSubscribers;
            bool returnValue = true;

            eventSubscribers = eventHandler.GetInvocationList();
            eventHandlers = new EventHandler<TEventArgs>[eventSubscribers.Length];

            for (int i = 0; i < eventSubscribers.Length; i++)
            {
                if (eventSubscribers[i] is EventHandler<TEventArgs> eventHandlerItem)
                    eventHandlers[i] = eventHandlerItem;
                else
                {
                    returnValue = false;
                    break;
                }
            }

            if (!returnValue)
                eventHandlers = null;

            return returnValue;
        }

        #endregion
        #region _Public_
        /// <summary>
        /// Raises an event asnchronously for all subscribers.
        /// </summary>
        /// <param name="eventHandler">An EventHandler that is the event handler.</param>
        /// <param name="sender">An object that is the sender of the event.</param>
        public static Task InvokeAsync(this EventHandler eventHandler, object sender)
        {
            if (eventHandler != null)
            {
                if (TryGetEventHandlers(eventHandler, out EventHandler[] eventHandlers))
                    InvokeListeners(sender, eventHandlers);
                else
                    throw new ArgumentException("Unable to obtain event handlers", nameof(eventHandler));
            }

            return Task.CompletedTask;
        }
        /// <summary>
        /// Raises an event asnchronously for all subscribers with a single event argument.
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="eventHandler">An EventHandler that is the event handler.</param>
        /// <param name="sender">An object that is the sender of the event.</param>
        /// <param name="eventArgs">A TEventArgs containing the event arguments.</param>
        public static Task InvokeAsync<TEventArgs>(this EventHandler<TEventArgs> eventHandler, object sender, TEventArgs eventArgs)
            where TEventArgs : EventArgs
        {
            return InvokeAsync(eventHandler, sender, () => eventArgs);
        }
        /// <summary>
        /// Raises an event asnchronously for all subscribers with an event argument factory.
        /// </summary>
        /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
        /// <param name="eventHandler">An EventHandler that is the event handler.</param>
        /// <param name="sender">An object that is the sender of the event.</param>
        /// <param name="eventArgsFactory">A Func that generates event arguments of type TEventArgs.</param>
        public static Task InvokeAsync<TEventArgs>(this EventHandler<TEventArgs> eventHandler, object sender, Func<TEventArgs> eventArgsFactory)
            where TEventArgs : EventArgs
        {
            if (eventHandler != null)
            {
                if (TryGetEventHandlers(eventHandler, out EventHandler<TEventArgs>[] eventHandlers))
                    InvokeListeners(sender, eventHandlers, eventArgsFactory);
                else
                    throw new ArgumentException("Unable to obtain event handlers", nameof(eventHandler));
            }

            return Task.CompletedTask;
        }

        #endregion
        #endregion
    }
}